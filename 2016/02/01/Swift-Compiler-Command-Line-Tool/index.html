<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Swift Compiler Command Line Tool · Avatar</title><meta name="description" content="Swift Compiler Command Line Tool - Avatar.iOS"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/logo3.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Swift Compiler Command Line Tool</h1><div class="post-meta"><div class="post-time"><p><strong>lisi</strong> Feb 1, 2016</p></div></div><div class="post-content"><p>Xcode作为一个功能还算强大的IDE，为iOS，OSX的开发提供了极大的便利，我们通常使用Xcode作为Swift开发的IDE。然而Swift作为一门准全栈语言，在其他开发领域使用时，以Xcode作为IDE并不一定是一个理想选择。也有很多Linux C或者嵌入式开发的同学习惯使用编辑器结合Compile Tool Chain进行开发。本文讨论脱离了Xcode，我们应该如何组织和构建Swift工程。</p>
<h2 id="Swift_Compiler"><a href="#Swift_Compiler" class="headerlink" title="Swift Compiler"></a>Swift Compiler</h2><p>Swift编译器位于/usr/bin/swift。首先看一下Documentation</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span> swift</span><br></pre></td></tr></table></figure>
<p>Swift Compiler包括了swift和swiftc两个命令。<br>其中swift命令可以输入program arguments<br>swiftc支持多种模式，包括生成object file，library，assembly等。<br>具体用法看一下help</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">swift </span>-h</span><br><span class="line"><span class="keyword">swiftc </span>-h</span><br></pre></td></tr></table></figure>
<p>两个帮助文档的内容差别不大，可以当作同一个使用。下面介绍一下一些参数的含义</p>
<h3 id="MODES"><a href="#MODES" class="headerlink" title="MODES"></a>MODES</h3><p>Swift Compiler有几种模式，可以输出不同的文件：</p>
<ul>
<li>-emit-library 生成一个库文件</li>
<li>-emit-object 生成一个object file</li>
<li>-emit-executable 生成可执行文件</li>
</ul>
<p>还有一些模式可以生成一些编译中间文件，如IR，SIL，asembly等。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>Swift Compiler有很多命令行参数，这里列举几个重要参数：</p>
<ul>
<li>-emit-module 生成一个module</li>
<li>-emit-module-path 输出module文件的路径</li>
<li>-I 所引入module的搜索路径</li>
<li>-L 链接库的搜索路径</li>
<li>-l 需要链接的库</li>
<li>-module-name 生成module时指定module的名字</li>
<li>-module-link-name 生成module时告诉编译器module对应于哪个库</li>
<li>-o 指定输出文件名<br>其他还有一些命令如嵌入BitCode，编译器优化选项，加入debug信息等。</li>
</ul>
<p>总体来看，命令行参数和GCC的参数风格类似：-I的module搜索路径类似于C中的头文件搜索路径，-L，-l，-o的含义也是基本一致的。熟悉GCC的同学上手应该很快。</p>
<h2 id="Hello_world"><a href="#Hello_world" class="headerlink" title="Hello world"></a>Hello world</h2><p>我们用Swift编译器构建运行一个Hello World。</p>
<p>首先要用Swift写一个Hello Wolrd：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"print(\"</span>Hello World\<span class="string">")"</span> &gt; HelloWorld.swift</span><br></pre></td></tr></table></figure>
<p>然后用编译器编译生成一个可执行文件，名为MyFirstSwiftProgram.out：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">swiftc </span>HelloWorld.<span class="keyword">swift </span>-o MyFirstSwiftProgram.out</span><br></pre></td></tr></table></figure>
<p>运行这个可执行文件:</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">744</span> MyFirstSwiftProgram.<span class="keyword">out</span> &amp;&amp; ./MyFirstSwiftProgram.<span class="keyword">out</span></span><br></pre></td></tr></table></figure>
<p>也可以把Swift作为脚本执行：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"print(\"</span>Hello World\<span class="string">")"</span> <span class="string">| swift</span></span><br></pre></td></tr></table></figure>
<p>也可以在代码第一行加入 #!/usr/bin/swift，然后直接执行.swift文件。这时内核加载文件内容时查找#!后面的命令并执行。</p>
<p>可以看出/usr/bin/swift和/usr/bin/swiftc有一点区别就是/usr/bin/swift还可以扮演解释器的角色，如此一来还可以把swift作为一门脚本语言。</p>
<h2 id="u7F16_u8BD1_u751F_u6210module"><a href="#u7F16_u8BD1_u751F_u6210module" class="headerlink" title="编译生成module"></a>编译生成module</h2><p>在工程中我们经常用到库，可以用GCC编译生成一个动态库或者静态库。Swift引入了module的概念，我们可以更简单方便的组织代码，造轮子和使用轮子。</p>
<h3 id="awesomeModule"><a href="#awesomeModule" class="headerlink" title="awesomeModule"></a>awesomeModule</h3><p>我们开始构造一个名为awesome的module。首先写一段代码作为module的内容，命名为awesomeUtils.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">awesomeFoo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"foo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">awesomeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> str = <span class="string">"Hellow World"</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(string:<span class="type">String</span>) &#123;</span><br><span class="line">        str = string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">verbose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编译生成module，同时生成library和module。module命名为awesomeModule，生成的动态库为libawesome.dylib：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc awesomeUtils.swift -emit-<span class="keyword">module</span> -emit-library -<span class="keyword">module</span>-<span class="keyword">name</span> awesomeModule -o libawesome.dylib -<span class="keyword">module</span>-link-<span class="keyword">name</span> awesome</span><br></pre></td></tr></table></figure>
<p>其中-module-link-name选项可以告诉编译器import这个module时需要链接的库名，这里awesome module对应的动态库名为awesome。</p>
<p>这时，当前目录会生成这样几个文件：</p>
<ul>
<li>awesomeModule.swiftmodule</li>
<li>awesomeModule.swiftdoc</li>
<li>libawesome.dylib</li>
</ul>
<p>其中.swiftmodule就是我们得到的module，.swiftdoc是由代码注释生成的documents，dylib是得到的动态库。这样我们的module就构造完成了。</p>
<p>另外可以看下swiftmodule文件，它是一个二进制文件，二进制中有哪些可读内容：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">strings </span>awesomeModule.<span class="keyword">swiftmodule</span></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">awesomeModule</span></span><br><span class="line"><span class="label">LLVM</span> <span class="number">7</span>.<span class="number">0</span>.<span class="number">2</span></span><br><span class="line"><span class="label">x86_64</span>-apple-macosx10.<span class="number">11</span></span><br><span class="line"><span class="label">Foundation</span></span><br><span class="line"><span class="keyword">Swift</span><br><span class="line"></span><span class="label">awesome</span></span><br><span class="line"><span class="label">AwesomeUtil</span></span><br><span class="line"><span class="label">awesomeFoo</span></span><br><span class="line"><span class="keyword">string</span><br><span class="line"></span><span class="label">verbose</span></span><br><span class="line"><span class="keyword">self</span><br><span class="line"></span><span class="label">value</span></span><br><span class="line"><span class="keyword">buffer</span><br><span class="line"></span><span class="label">callbackStorage</span></span><br><span class="line"><span class="keyword">Swift</span><br><span class="line"></span><span class="keyword">String</span><br><span class="line"></span><span class="label">RawPointer</span></span><br><span class="line"><span class="label">UnsafeValueBuffer</span></span><br><span class="line"><span class="label">AnyObject</span></span><br><span class="line"><span class="label">AwesomeUtilI</span></span><br><span class="line"><span class="label">awesomeFooC</span></span><br><span class="line"><span class="label">dealloc</span></span><br></pre></td></tr></table></figure>
<p>内容大概包括了module的名字，编译环境，cpu架构，依赖的module，对应的library名字，还有代码中的一些字符串，像aweseomeFoo, AwesomeUtil。</p>
<h3 id="CoolModule"><a href="#CoolModule" class="headerlink" title="CoolModule"></a>CoolModule</h3><p>再来构造一个依赖于awesomeModule的module，创建一个名为CoolUtils.swift的文件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> awesomeModule</span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">cool</span><span class="params">()</span></span> &#123;</span><br><span class="line">    awesomeFoo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Cool"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译生成Cool module：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc CoolUtils.swift -I. -L. -emit-library -emit-<span class="keyword">module</span> -o libCool.dylib -<span class="keyword">module</span>-<span class="keyword">name</span> CoolModule -<span class="keyword">module</span>-link-<span class="keyword">name</span> Cool</span><br></pre></td></tr></table></figure>
<p>需要指定依赖的module路径和library路径，这里是当前目录；生成名为libCool的动态库，生成的module名为CoolModule，这个module对应的库文件为libCool。</p>
<h2 id="u4F7F_u7528Module"><a href="#u4F7F_u7528Module" class="headerlink" title="使用Module"></a>使用Module</h2><p>上文生成了两个module。现在创建一个依赖于这两个module的程序。</p>
<p>首先写一段代码使用上面构造的两个module提供的功能，命名为Bar.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> awesomeModule</span><br><span class="line"><span class="keyword">import</span> CoolModule</span><br><span class="line"><span class="comment">// Call the public functions in module of awesome and Cool</span></span><br><span class="line">awesomeFoo()</span><br><span class="line">cool()</span><br><span class="line"><span class="comment">// Use the public class awesomeUtil in module of awesome</span></span><br><span class="line"><span class="keyword">let</span> awesome = awesomeUtil(string: <span class="string">"That's cool"</span>)</span><br><span class="line">awesome.verbose()</span><br></pre></td></tr></table></figure>
<p>编译Bar为可执行文件，生成可执行文件Bar.out</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc Bar<span class="class">.swift</span> -o Bar<span class="class">.out</span> -I. -L. -emit-executable</span><br></pre></td></tr></table></figure>
<p>可以看出使用module非常便捷，只需在代码中引入相关的module，并在编译命令行中指定module和library的搜索路径即可，无需指定需要链接的库。</p>
<h2 id="u4F7F_u7528Makefile_u63A7_u5236_u6784_u4EF6_u8FC7_u7A0B"><a href="#u4F7F_u7528Makefile_u63A7_u5236_u6784_u4EF6_u8FC7_u7A0B" class="headerlink" title="使用Makefile控制构件过程"></a>使用Makefile控制构件过程</h2><p>Linux环境的工程通常使用自动化工具进行构建，诸如AutoTools, CMake。对于简单的工程，也可直接写一个makefile组织工程依赖和构建过程。我们尝试写一个简单的makefile把上述Swift代码的构建过程组织起来：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SC</span>=swiftc</span><br><span class="line"><span class="type">AWESOMEMODULE</span>=awesomeModule</span><br><span class="line"><span class="type">COOLMODULE</span>=<span class="type">CoolModule</span></span><br><span class="line"><span class="type">LIBAWESOME</span>=libawesome.dylib</span><br><span class="line"><span class="type">LIBCOOL</span>=libCool.dylib</span><br><span class="line"></span><br><span class="line">$(<span class="type">LIBaweSOME</span>):</span><br><span class="line">        $(<span class="type">SC</span>) awesomeUtils.swift -emit-<span class="module"><span class="keyword">module</span> -emit-library -<span class="keyword">module</span>-name $<span class="container">(<span class="type">AWESOMEMODULE</span>)</span> -o $<span class="container">(<span class="type">LIBAWESOME</span>)</span> -<span class="keyword">module</span>-link-name Awesome</span><br><span class="line"></span><br><span class="line">$<span class="container">(<span class="type">LIBCOOL</span>)</span>: $<span class="container">(<span class="type">LIBaweSOME</span>)</span></span><br><span class="line">        $<span class="container">(<span class="type">SC</span>)</span> CoolUtils.swift -emit-<span class="keyword">module</span> -emit-library -<span class="keyword">module</span>-name $<span class="container">(<span class="type">COOLMODULE</span>)</span> -o $<span class="container">(<span class="type">LIBCOOL</span>)</span> -I. -L. -<span class="keyword">module</span>-link-name Cool</span><br><span class="line"></span><br><span class="line">BarMake: $<span class="container">(<span class="type">LIBaweSOME</span>)</span> $<span class="container">(<span class="type">LIBCOOL</span>)</span></span><br><span class="line">        $<span class="container">(<span class="type">SC</span>)</span> Bar.swift -I. -L. -o Bar.out -emit-executable</span></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>make BarMake</code> 就完成包括module的编译和可执行文件的构建。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本文讨论了Swift编译器工具的基本用法，使用command line tool构建Swift Module，构建可执行文件。</p>
<p>Module的引入不仅在代码层面带来诸多便利，在工程组织与构建时，把库的依赖关系直接包含在module内容里，不需要在编译命令中指定依赖的库，减少了构建的复杂度。</p>
<p>对于使用Swift进行非基于Cocoa的开发，即便在Linux或者Windows环境中，仍然可以通过Makefile或者CMake, Scons等工具优雅地组织和构建工程。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/27/Swift学习笔记－－OptionSetType/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'avatarios';
var disqus_identifier = '2016/02/01/Swift-Compiler-Command-Line-Tool/';
var disqus_title = 'Swift Compiler Command Line Tool';
var disqus_url = 'http://yoursite.com/2016/02/01/Swift-Compiler-Command-Line-Tool/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//avatarios.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">Avatar.iOS</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>