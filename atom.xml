<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Avatar]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-27T12:16:51.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Avatar.iOS]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift学习笔记－－OptionSetType]]></title>
    <link href="http://yoursite.com/2016/01/27/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%EF%BC%8DOptionSetType/"/>
    <id>http://yoursite.com/2016/01/27/Swift学习笔记－－OptionSetType/</id>
    <published>2016-01-27T12:11:48.000Z</published>
    <updated>2016-01-27T12:16:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5B9E_u73B0_u81EA_u5B9A_u4E49_u591A_u9009_u7C7B_u578B"><a href="#u5B9E_u73B0_u81EA_u5B9A_u4E49_u591A_u9009_u7C7B_u578B" class="headerlink" title="实现自定义多选类型"></a>实现自定义多选类型</h1><h2 id="Objective-C_u4E2D_u7684_u679A_u4E3E_u591A_u9009"><a href="#Objective-C_u4E2D_u7684_u679A_u4E3E_u591A_u9009" class="headerlink" title="Objective-C中的枚举多选"></a>Objective-C中的枚举多选</h2><p>UIView的一个常用属性是autoresizingMask是一个枚举类型，在设置其值时通常被设置为多个值的组合，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, UIViewAutoresizing)</span> </span>&#123;</span><br><span class="line">    UIViewAutoresizingNone                 = <span class="number">0</span>,</span><br><span class="line">    UIViewAutoresizingFlexibleLeftMargin   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    UIViewAutoresizingFlexibleWidth        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    UIViewAutoresizingFlexibleRightMargin  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    UIViewAutoresizingFlexibleTopMargin    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    UIViewAutoresizingFlexibleHeight       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    UIViewAutoresizingFlexibleBottomMargin = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line">view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;</span><br></pre></td></tr></table></figure>
<p>OC中的枚举值其实就是整数值，所以可以通过按位与操作来实现多选</p>
<h2 id="Swift_u4E2D_u7684_u591A_u9009"><a href="#Swift_u4E2D_u7684_u591A_u9009" class="headerlink" title="Swift中的多选"></a>Swift中的多选</h2><p>那在swift中该怎么做呢，swift中的enum不再是整数类型，所以是不能再使用按位与操作，看下swift中autoresizingMask是怎么定义和使用的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UIViewAutoresizing</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">None</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleLeftMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleWidth</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleRightMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleTopMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleHeight</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">FlexibleBottomMargin</span>: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">view.autoresizingMask = [.<span class="type">FlexibleHeight</span>, .<span class="type">FlexibleHeight</span>]</span><br></pre></td></tr></table></figure></p>
<p>swift中的UIViewAutoresizing不再是enum类型，而是一个遵从了OptionSetType协议的struct，然后所有的可能值被定义为public的readonly的static变量，并且这些可能的值的类型都是UIViewAutoresizing，在使用多个值的时候，把多个可能值放到一个数组中，然后赋值就可以了</p>
<h2 id="u5728swift_u4E2D_u5B9E_u73B0_u81EA_u5B9A_u4E49_u7684_u591A_u9009_u7C7B_u578B"><a href="#u5728swift_u4E2D_u5B9E_u73B0_u81EA_u5B9A_u4E49_u7684_u591A_u9009_u7C7B_u578B" class="headerlink" title="在swift中实现自定义的多选类型"></a>在swift中实现自定义的多选类型</h2><p>上面我们看到了UIViewAutoresizing在Swift中是怎么实现的,那是不是能照着样子来实现一个自定义的多选类型呢,就像这样<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">East</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">South</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">West</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Nouth</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而不行,像上面的代码会被编译器无情的拒绝<br><img src="https://cloud.githubusercontent.com/assets/1595401/12009254/9de711b6-acab-11e5-81bf-bae4d8ff132d.png" alt="image"></p>
<p>完整的写法应该是这样的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue : <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>) &#123; <span class="keyword">self</span>.rawValue = rawValue &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">East</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">0</span>) &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">South</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">1</span>) &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">West</span>  : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">1</span>) &#125; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Nouth</span> : <span class="type">Direction</span> &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">2</span>) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样虽然编译器不抱怨了,但太繁琐,下面是更简洁的写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> rawValue : <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>) &#123; <span class="keyword">self</span>.rawValue = rawValue&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">East</span>  = <span class="type">Direction</span>(rawValue : <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">South</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">West</span>  = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Nouth</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果这个多选类型不会被外部的模块使用,还可以再简写一下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Direction</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue : <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">East</span>  = <span class="type">Direction</span>(rawValue : <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">South</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">West</span>  = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Nouth</span> = <span class="type">Direction</span>(rawValue : <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用方式和UIViewAutoresizing是一致的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> direction : <span class="type">Direction</span> = [.<span class="type">East</span>, .<span class="type">South</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Swift_u591A_u9009_u7C7B_u578B_u652F_u6301_u7684_u64CD_u4F5C"><a href="#Swift_u591A_u9009_u7C7B_u578B_u652F_u6301_u7684_u64CD_u4F5C" class="headerlink" title="Swift多选类型支持的操作"></a>Swift多选类型支持的操作</h2><p>在Objective-c中可以通过位运算来检查一个多选项是否被包含在一个枚举变量中,还可以向一个枚举变量增加一个选项,在swift对应的操作是什么呢? 这时就要到OptionSetType这个协议来找答案了,先看下这个协议是怎么定义的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Supplies convenient conformance to `SetAlgebraType` for any type</span></span><br><span class="line"><span class="comment">/// whose `RawValue` is a `BitwiseOperationsType`.  For example:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///     struct PackagingOptions : OptionSetType &#123;</span></span><br><span class="line"><span class="comment">///       let rawValue: Int</span></span><br><span class="line"><span class="comment">///       init(rawValue: Int) &#123; self.rawValue = rawValue &#125;</span></span><br><span class="line"><span class="comment">///     </span></span><br><span class="line"><span class="comment">///       static let Box = PackagingOptions(rawValue: 1)</span></span><br><span class="line"><span class="comment">///       static let Carton = PackagingOptions(rawValue: 2)</span></span><br><span class="line"><span class="comment">///       static let Bag = PackagingOptions(rawValue: 4)</span></span><br><span class="line"><span class="comment">///       static let Satchel = PackagingOptions(rawValue: 8)</span></span><br><span class="line"><span class="comment">///       static let BoxOrBag: PackagingOptions = [Box, Bag]</span></span><br><span class="line"><span class="comment">///       static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag]</span></span><br><span class="line"><span class="comment">///     &#125;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In the example above, `PackagingOptions.Element` is the same type</span></span><br><span class="line"><span class="comment">/// as `PackagingOptions`, and instance `a` subsumes instance `b` if</span></span><br><span class="line"><span class="comment">/// and only if `a.rawValue &amp; b.rawValue == b.rawValue`.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">OptionSetType</span> : <span class="title">SetAlgebraType</span>, <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// An `OptionSet`'s `Element` type is normally `Self`.</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Convert from a value of `RawValue`, succeeding unconditionally.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">Self</span>.<span class="type">RawValue</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是OptionSetType协议在标准库里面的定义, 这里我们只看到这个协议继承了两个协议SetAlgebraType和RawRepresentable, RawRepresentable比较简单</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A type that can be converted to an associated "raw" type, then</span></span><br><span class="line"><span class="comment">/// converted back to produce an instance equivalent to the original.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The "raw" type that can be used to represent all values of `Self`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Every distinct value of `self` has a corresponding unique</span></span><br><span class="line">    <span class="comment">/// value of `RawValue`, but `RawValue` may have representations</span></span><br><span class="line">    <span class="comment">/// that do not correspond to an value of `Self`.</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">RawValue</span></span><br><span class="line">    <span class="comment">/// Convert from a value of `RawValue`, yielding `nil` iff</span></span><br><span class="line">    <span class="comment">/// `rawValue` does not correspond to a value of `Self`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>?(rawValue: <span class="type">Self</span>.<span class="type">RawValue</span>)</span><br><span class="line">    <span class="comment">/// The corresponding value of the "raw" type.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// `Self(rawValue: self.rawValue)!` is equivalent to `self`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rawValue: <span class="type">Self</span>.<span class="type">RawValue</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而更重要的是SetAlgebraType</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A generalized set whose distinct elements are not necessarily</span></span><br><span class="line"><span class="comment">/// disjoint.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In a model of `SetAlgebraType`, some elements may subsume other</span></span><br><span class="line"><span class="comment">/// elements, where</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// &gt; `a` **subsumes** `b` iff `([a] as Self).isSupersetOf([b])`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In many models of `SetAlgebraType` such as `Set&lt;T&gt;`, `a`</span></span><br><span class="line"><span class="comment">/// *subsumes* `b` if and only if `a == b`, but that is not always the</span></span><br><span class="line"><span class="comment">/// case.  For example, option sets typically do not satisfy that</span></span><br><span class="line"><span class="comment">/// property.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Two elements are **disjoint** when neither one *subsumes* the other.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - SeeAlso: `OptionSetType`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Axioms, where `S` conforms to `SetAlgebraType`, `x` and `y` are</span></span><br><span class="line"><span class="comment">///   of type `S`, and `e` is of type `S.Element`:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///   - `S() == []`</span></span><br><span class="line"><span class="comment">///   - `x.intersect(x) == x`</span></span><br><span class="line"><span class="comment">///   - `x.intersect([]) == []`</span></span><br><span class="line"><span class="comment">///   - `x.union(x) == x`</span></span><br><span class="line"><span class="comment">///   - `x.union([]) == x`</span></span><br><span class="line"><span class="comment">///   - `x.contains(e)` implies `x.union(y).contains(e)`</span></span><br><span class="line"><span class="comment">///   - `x.union(y).contains(e)` implies `x.contains(e) || y.contains(e)`</span></span><br><span class="line"><span class="comment">///   - `x.contains(e) &amp;&amp; y.contains(e)` iff `x.intersect(y).contains(e)`</span></span><br><span class="line"><span class="comment">///   - `x.isSubsetOf(y)` iff `y.isSupersetOf(x)`</span></span><br><span class="line"><span class="comment">///   - `x.isStrictSupersetOf(y)` iff `x.isSupersetOf(y) &amp;&amp; x != y`</span></span><br><span class="line"><span class="comment">///   - `x.isStrictSubsetOf(y)` iff `x.isSubsetOf(y) &amp;&amp; x != y`</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">SetAlgebraType</span> : <span class="title">Equatable</span>, <span class="title">ArrayLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// A type for which `Self` provides a containment test.</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span></span><br><span class="line">    <span class="comment">/// Creates an empty set.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `[] as Self`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="comment">/// Returns `true` if `self` contains `member`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `self.intersect([member]) == [member]`</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(member: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Returns the set of elements contained in `self`, in `other`, or in</span></span><br><span class="line">    <span class="comment">/// both `self` and `other`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">union</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Returns the set of elements contained in both `self` and `other`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Returns the set of elements contained in `self` or in `other`,</span></span><br><span class="line">    <span class="comment">/// but not in both `self` and `other`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">exclusiveOr</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// If `member` is not already contained in `self`, inserts it.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `self.unionInPlace([member])`</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.contains(member)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(member: <span class="keyword">Self</span>.Element)</span></span></span><br><span class="line">    <span class="comment">/// If `member` is contained in `self`, removes and returns it.</span></span><br><span class="line">    <span class="comment">/// Otherwise, removes all elements subsumed by `member` and returns</span></span><br><span class="line">    <span class="comment">/// `nil`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.intersect([member]).isEmpty`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(member: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Element</span>?</span><br><span class="line">    <span class="comment">/// Insert all elements of `other` into `self`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.union(other)`.</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.isSupersetOf(other)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">unionInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Removes all elements of `self` that are not also present in</span></span><br><span class="line">    <span class="comment">/// `other`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.intersect(other)`</span></span><br><span class="line">    <span class="comment">/// - Postcondition: `self.isSubsetOf(other)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">intersectInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Replaces `self` with a set containing all elements contained in</span></span><br><span class="line">    <span class="comment">/// either `self` or `other`, but not both.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.exclusiveOr(other)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">exclusiveOrInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Return true iff `self.intersect(other).isEmpty`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">subtract</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">/// Return true iff every element of `self` is contained in `other`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">isSubsetOf</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Return true iff `self.intersect(other).isEmpty`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">isDisjointWith</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Return true iff every element of `other` is contained in `self`.</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">isSupersetOf</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Return true iff `self.contains(e)` is `false` for all `e`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// Creates the set containing all elements of `sequence`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span> : <span class="type">SequenceType</span> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Generator</span>.<span class="type">Element</span> == <span class="type">Element</span>&gt;(<span class="number">_</span> sequence: <span class="type">S</span>)</span><br><span class="line">    <span class="comment">/// Removes all elements of `other` from `self`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to replacing `self` with `self.subtract(other)`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">subtractInPlace</span><span class="params">(other: <span class="keyword">Self</span>)</span></span></span><br><span class="line">    <span class="comment">/// Returns `true` iff `a` subsumes `b`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Equivalent to `([a] as Self).isSupersetOf([b])`</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">element</span><span class="params">(a: <span class="keyword">Self</span>.Element, subsumes b: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="comment">/// Returns `true` iff `a` is disjoint with `b`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Two elements are disjoint when neither one subsumes the other.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - SeeAlso: `Self.element(_, subsumes:_)`</span></span><br><span class="line">    <span class="preprocessor">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">element</span><span class="params">(a: <span class="keyword">Self</span>.Element, isDisjointWith b: <span class="keyword">Self</span>.Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SetAlgebraType就像其名字一样,声明了众多集合代数类型的操作,在标准库中,大部分这些方法都以extension的方式提供了默认的实现,所以可以供我们直接使用,以之前定义的Direction为例,</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> direction1 : <span class="type">Direction</span> = [.<span class="type">East</span>, .<span class="type">South</span>]</span><br><span class="line"><span class="keyword">var</span> direction2 : <span class="type">Direction</span> = [.<span class="type">East</span>, .<span class="type">North</span>]</span><br></pre></td></tr></table></figure>
<p><strong>添加一个选项</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction1.insert(.<span class="type">West</span>)</span><br></pre></td></tr></table></figure>
<p><strong>检查一个选项是否被包含</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containEast : <span class="type">Bool</span> = direction1.<span class="built_in">contains</span>(.<span class="type">East</span>)</span><br></pre></td></tr></table></figure>
<p><strong>两个多选类型值的交集</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directoin = direction1.intersect(direction2)</span><br></pre></td></tr></table></figure>
<p>还有其他的操作这里就不再列举了</p>
<p>这里还提一点就是SetAlgebraType继承自ArrayLiteralConvertible, 从名字我们就能看出来为什么自定义的多选类型变量可以通过数值字面量赋值了, 具体细节请参考标准库里面的说明吧</p>
<h2 id="u5199_u5728_u6700_u540E_3AWhy_3F"><a href="#u5199_u5728_u6700_u540E_3AWhy_3F" class="headerlink" title="写在最后:Why?"></a>写在最后:Why?</h2><p>那为什么在swift中要把之前我们用的好好的枚举实现成这样的?我个人认为最重要的就是两个字:<strong>类型</strong><br>在OC中,枚举其实就是整数类型, 枚举选项就是整型常量, 枚举变量就是一个整型的变量,所以可以把一个整数赋值给一个枚举变量, 也可以把枚举变量当做整型变量来使用,所以可以说OC中是不存在真正的多选类型.虽然这样有了灵活性,但丧失了类型信息,也就没了安全性.比如我们可以把一个不是任何有效选项的整数值赋值给一个枚举变量,而编译器并不会抱怨.</p>
<p>Swift是一门很强调安全性的语言,而强类型就是方式之一.这种强类型系统已经不允许我们把0当做Bool类型中的false来使用了,比如下面的代码就会被编译器无情的拒绝</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b : <span class="type">Bool</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在Swift中的多选类型不再等同于整型,严格的说是不再等同任何其他类型,这样看起来是丧失了灵活性,但是带来的好处是我们不能也不允许把一个无效的值赋给多选类型变量了,因为编译器能够很好的检查出来这样错误,避免把隐患带到执行期,来提高程序的安全性.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5B9E_u73B0_u81EA_u5B9A_u4E49_u591A_u9009_u7C7B_u578B"><a href="#u5B9E_u73B0_u81EA_u5B9A_u4E49_u591A_u9009_u7C7B_u578B" class="heade]]>
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
  </entry>
  
</feed>
